<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jira Project Analytics Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: white;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            color: white;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #667eea;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #2a2a4e;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            background: #a02020;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .metric-card {
            background: #16213e;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
            border: 1px solid #2a2a4e;
            cursor: pointer;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            border-color: #667eea;
        }
        
        .metric-card h3 {
            font-size: 0.9em;
            color: #a8a8b3;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .metric-card .value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .metric-card .subtitle {
            font-size: 0.9em;
            color: #888;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .chart-box {
            background: #16213e;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            border: 1px solid #2a2a4e;
            position: relative;
        }
        
        .chart-box h3 {
            margin-bottom: 20px;
            color: #eee;
            font-size: 1.3em;
        }
        
        .chart-box canvas {
            cursor: pointer;
            position: relative;
            z-index: 1;
            transition: transform 0.2s ease;
        }

        .chart-box canvas:hover {
            transform: scale(1.02);
        }

        .chart-box:hover {
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .chart-box {
            position: relative;
            overflow: visible;
        }
        
        .insights-section {
            background: #16213e;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            border: 1px solid #2a2a4e;
            margin-bottom: 30px;
        }
        
        .insights-section h2 {
            margin-bottom: 20px;
            color: #667eea;
            font-size: 1.8em;
        }
        
        .insight-item {
            background: #1a1a2e;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .insight-item h4 {
            color: #fff;
            margin-bottom: 10px;
        }
        
        .insight-item p {
            color: #a8a8b3;
            line-height: 1.6;
        }
        
        .top-performers {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .performer-card {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #2a2a4e;
        }
        
        .performer-card h4 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .performer-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2a2a4e;
        }
        
        .performer-item:last-child {
            border-bottom: none;
        }
        
        .progress-bar {
            background: #2a2a4e;
            height: 6px;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.5s ease;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            overflow: auto;
        }
        
        .modal-content {
            background-color: #16213e;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #667eea;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        .close:hover,
        .close:focus {
            color: #667eea;
        }
        
        .modal h2 {
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #2a2a4e;
        }
        
        .data-table th {
            background: #1a1a2e;
            color: #667eea;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .data-table tr:hover {
            background: #1a1a2e;
        }
        
        .data-table a {
            color: #667eea;
            text-decoration: none;
        }
        
        .data-table a:hover {
            text-decoration: underline;
        }
        
        .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .status-done {
            background: #2d7a2d;
            color: white;
        }
        
        .status-progress {
            background: #d4a017;
            color: white;
        }
        
        .status-assigned {
            background: #5a5a5a;
            color: white;
        }
        
        .status-blocked {
            background: #a02020;
            color: white;
        }
        
        .status-canceled {
            background: #444;
            color: #aaa;
        }
        
        .filter-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .filter-controls input,
        .filter-controls select {
            padding: 8px 15px;
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            color: #eee;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .filter-controls input:focus,
        .filter-controls select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .ticket-description {
            background: #1a1a2e;
            padding: 15px;
            margin-top: 10px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
            display: none;
        }
        
        .ticket-description.show {
            display: block;
        }
        
        .expand-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background 0.3s;
        }
        
        .expand-btn:hover {
            background: #764ba2;
        }
        
        .config-section {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #2a2a4e;
        }
        
        .config-section h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .config-form {
            display: block;
            width: 100%;
        }

        /* Legacy flex layout for forms without grid */
        .config-form.legacy-flex {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .config-form label {
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: #a8a8b3;
        }
        
        .config-form input {
            padding: 8px 12px;
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            color: #eee;
            border-radius: 5px;
            width: 300px;
        }
        
        .config-form button {
            padding: 12px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.9em;
            font-weight: 500;
        }

        .config-form button:hover {
            background: #764ba2;
        }

        /* Load Data button with enhanced orange styling and pulsing glow */
        .load-data-btn {
            background: #ff8c00 !important;
            color: white !important;
            border: 1px solid rgba(255, 140, 0, 0.5) !important;
            box-shadow:
                0 0 20px rgba(255, 140, 0, 0.6),
                0 0 40px rgba(255, 140, 0, 0.4),
                0 0 60px rgba(255, 140, 0, 0.2) !important;
            animation: pulseGlow 2.5s ease-in-out infinite;
            position: relative;
            overflow: visible;
        }

        .load-data-btn:hover {
            background: #ffaa33 !important;
            color: white !important;
        }

        /* Pulsing glow animation */
        @keyframes pulseGlow {
            0% {
                box-shadow:
                    0 0 20px rgba(255, 140, 0, 0.6),
                    0 0 40px rgba(255, 140, 0, 0.4),
                    0 0 60px rgba(255, 140, 0, 0.2);
            }
            50% {
                box-shadow:
                    0 0 30px rgba(255, 140, 0, 0.8),
                    0 0 60px rgba(255, 140, 0, 0.6),
                    0 0 90px rgba(255, 140, 0, 0.3);
            }
            100% {
                box-shadow:
                    0 0 20px rgba(255, 140, 0, 0.6),
                    0 0 40px rgba(255, 140, 0, 0.4),
                    0 0 60px rgba(255, 140, 0, 0.2);
            }
        }



        /* Accessibility: Respect user's motion preferences */
        @media (prefers-reduced-motion: reduce) {
            .load-data-btn {
                animation: none !important;
                box-shadow: 0 0 20px rgba(255, 140, 0, 0.6) !important;
            }
        }



        /* Autocomplete dropdown styles */
        .autocomplete-container {
            position: relative;
            width: 100%;
        }

        .view-all-projects-link {
            font-style: italic;
            color: #888;
            font-size: 0.85em;
            cursor: pointer;
            transition: color 0.2s ease;
            text-decoration: none;
            font-weight: normal;
            margin-left: 8px;
            white-space: nowrap;
            display: inline;
        }

        .view-all-projects-link:hover {
            color: #667eea;
            text-decoration: underline;
        }

        .autocomplete-input {
            width: 100%;
            padding: 8px 12px;
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            color: #eee;
            border-radius: 5px;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #16213e;
            border: 1px solid #2a2a4e;
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #2a2a4e;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #667eea;
            color: white;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .project-type {
            font-size: 0.8em;
            color: #a8a8b3;
            margin-left: 10px;
        }



        .credentials-toggle {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s ease;
            width: 100%;
        }

        .credentials-toggle.off {
            background: #667eea;
            color: white;
        }

        .credentials-toggle.off:hover {
            background: #764ba2;
        }

        .credentials-toggle.on {
            background: #28a745;
            color: white;
        }

        .credentials-toggle.saved {
            background: #28a745;
            color: white;
            cursor: default;
        }

        .credentials-toggle.error {
            background: #dc3545;
            color: white;
            cursor: pointer;
        }

        .credentials-toggle.validating {
            background: #ffc107;
            color: #212529;
            cursor: default;
        }

        .credentials-toggle:hover:not(.saved) {
            transform: translateY(-1px);
        }

        /* Ensure credentials toggle button matches grid layout */
        .config-grid-button-row .credentials-toggle {
            padding: 12px 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* AI Configuration Button Row - 3x1 responsive layout */
        .ai-config-button-row {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
            width: 100%;
        }

        .ai-config-button-row button {
            width: 100%;
            padding: 12px 20px;
            font-size: 0.9em;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .ai-config-button-row button:hover {
            background: #764ba2;
        }

        /* Responsive AI button layout - 1x3 grid for small screens */
        @media (max-width: 900px) {
            .ai-config-button-row {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        /* AI credentials toggle button styling */
        .ai-config-button-row .credentials-toggle {
            padding: 12px 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* Grid Layout Styles */
        .config-grid-2x2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .config-grid-2x1 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .config-grid-full-width {
            grid-column: 1 / -1;
            margin: 10px 0;
        }

        .config-grid-full-width button {
            width: 100%;
        }

        .config-grid-button-row {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
            width: 100%;
        }

        .config-grid-button-row button {
            width: 100%;
            padding: 12px 20px;
            font-size: 0.9em;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Responsive button layout - 3x1 for medium screens, then 1x3 for small */
        @media (max-width: 900px) {
            .config-grid-button-row {
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
            }
        }

        /* Responsive button layout - 1x3 grid for small screens */
        @media (max-width: 480px) {
            .config-grid-button-row {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .config-grid-button-row button {
                padding: 14px 20px;
                font-size: 1em;
            }
        }

        .config-grid-single-button {
            grid-column: 1 / -1;
            margin-top: 15px;
        }

        .config-grid-single-button button {
            width: 100%;
        }

        .config-form-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .config-form-field label {
            color: #a8a8b3;
            font-size: 0.9em;
            margin-bottom: 5px;
            display: block;
            line-height: 1.4;
        }

        .config-form-field input,
        .config-form-field select {
            padding: 8px 12px;
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            color: #eee;
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }

        .config-form-field small {
            display: block;
            margin-top: 5px;
            color: #888;
            font-size: 0.8em;
            line-height: 1.3;
        }

        /* Responsive Grid Adjustments */
        @media (max-width: 768px) {
            .config-grid-2x2,
            .config-grid-2x1 {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .config-grid-button-row {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .config-form-field input,
            .config-form-field select {
                width: 100%;
            }
        }

        /* Project List Modal Styles */
        .project-list-container {
            max-height: 60vh;
            overflow-y: auto;
            margin-top: 20px;
        }

        .project-category {
            margin-bottom: 25px;
        }

        .project-category h4 {
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a4e;
        }

        .project-item {
            padding: 12px 15px;
            margin: 5px 0;
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .project-item:hover {
            background: #667eea;
            color: white;
            transform: translateX(5px);
        }

        .project-key {
            font-weight: bold;
            color: #667eea;
            margin-right: 10px;
        }

        .project-item:hover .project-key {
            color: white;
        }

        .project-type-badge {
            background: #2a2a4e;
            color: #a8a8b3;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-left: 10px;
        }

        /* Inline Chat Interface Styles */
        .inline-chat-container {
            background: #16213e;
            border: 1px solid #2a2a4e;
            border-radius: 8px;
            margin: 20px 0 40px 0; /* Add bottom margin for spacing */
            max-width: 100%;
            height: 500px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .chat-header {
            background: #1a1a2e;
            padding: 15px 20px;
            border-bottom: 1px solid #2a2a4e;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h3 {
            margin: 0;
            color: #667eea;
            font-size: 1.1em;
        }

        .chat-close-btn {
            background: none;
            border: none;
            color: #a8a8b3;
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .chat-close-btn:hover {
            background: #2a2a4e;
            color: white;
        }

        .chat-messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        /* Chat Interface Styles */
        .chat-modal-content {
            max-width: 800px;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            flex: 1;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px 0;
            margin-bottom: 20px;
            border-bottom: 1px solid #2a2a4e;
        }

        .chat-message {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.ai {
            align-items: flex-start;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }

        .message-bubble.user {
            background: #667eea;
            color: white;
        }

        .message-bubble.ai {
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            color: #eee;
        }

        .message-timestamp {
            font-size: 0.75em;
            color: #888;
            margin-top: 5px;
        }

        .chat-input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input-container input {
            flex: 1;
            padding: 12px 16px;
            background: #1a1a2e;
            border: 1px solid #2a2a4e;
            color: #eee;
            border-radius: 25px;
            outline: none;
        }

        .chat-input-container input:focus {
            border-color: #667eea;
        }

        .chat-input-container button {
            padding: 12px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .chat-input-container button:hover {
            background: #764ba2;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0;
            color: #888;
            font-style: italic;
        }

        .typing-dots {
            display: flex;
            gap: 3px;
        }

        .typing-dots span {
            width: 6px;
            height: 6px;
            background: #667eea;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Markdown Styles for AI Responses */
        .message-bubble.ai h1,
        .message-bubble.ai h2,
        .message-bubble.ai h3 {
            color: #667eea;
            margin: 10px 0 5px 0;
        }

        .message-bubble.ai ul,
        .message-bubble.ai ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .message-bubble.ai code {
            background: #0f1419;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .message-bubble.ai pre {
            background: #0f1419;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .message-bubble.ai blockquote {
            border-left: 3px solid #667eea;
            padding-left: 15px;
            margin: 10px 0;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Jira Project Analytics - Live Data</h1>
        <p>Customer Engineering Service Desk Performance Dashboard</p>
        <p style="font-size: 0.9em; margin-top: 10px; opacity: 0.8;">Real-time data from Jira API</p>
    </div>
    
    <!-- Configuration Section -->
    <div class="config-section">
        <h3>API Configuration</h3>
        <form class="config-form" onsubmit="updateConfig(event)">
            <!-- Row 1: Base URL and Username -->
            <div class="config-grid-2x2">
                <div class="config-form-field">
                    <label for="baseUrl">Base URL:</label>
                    <input type="text" id="baseUrl" value="postmanlabs.atlassian.net" required>
                </div>
                <div class="config-form-field">
                    <label for="username">Username (Email):</label>
                    <input type="email" id="username" value="jared.boynton@postman.com" required>
                </div>

                <!-- Row 2: API Token and Project Key -->
                <div class="config-form-field">
                    <label for="apiToken">API Token:</label>
                    <input type="password" id="apiToken" placeholder="Enter your API token" required>
                    <div id="tokenStatus" style="display: none; margin-top: 5px; color: #667eea; font-size: 0.8em;"></div>
                </div>
                <div class="config-form-field">
                    <label for="projectKey">Project Key: <span class="view-all-projects-link" onclick="showProjectListModal()">(view all projects)</span></label>
                    <div class="autocomplete-container">
                        <input type="text" id="projectKey" class="autocomplete-input" value="" placeholder="Start typing to search projects..." required>
                        <div id="projectDropdown" class="autocomplete-dropdown"></div>
                    </div>
                    <small>Start typing to search available projects, or click "view all projects" to browse all options</small>
                </div>
            </div>

            <!-- Row 3: All Action Buttons -->
            <div class="config-grid-button-row">
                <button type="submit" class="load-data-btn">Load Data</button>
                <button type="button" id="credentialsToggle" class="credentials-toggle off" onclick="toggleCredentialsSaving()">Save Credentials</button>
                <button type="button" onclick="clearStoredCredentials()" style="background: #a02020;">Clear Stored Credentials</button>
            </div>
        </form>
    </div>

    <!-- AI Analysis Configuration Section -->
    <div class="config-section">
        <h3>AI Analysis Configuration</h3>
        <form class="config-form" id="openaiConfigForm">
            <!-- Row 1: API Key and Model Selection -->
            <div class="config-grid-2x2">
                <div class="config-form-field">
                    <label for="openaiApiKey">OpenAI API Key:</label>
                    <input type="password" id="openaiApiKey" placeholder="Enter your OpenAI API key">
                </div>
                <div class="config-form-field">
                    <label for="openaiModel">Model:</label>
                    <div class="autocomplete-container">
                        <input type="text" id="openaiModel" class="autocomplete-input" value="o3" placeholder="Select or type model name...">
                        <div id="modelDropdown" class="autocomplete-dropdown"></div>
                    </div>
                    <small>Select from list or enter custom model name</small>
                </div>
            </div>

            <!-- Row 2: AI Action Buttons -->
            <div class="ai-config-button-row">
                <button type="button" onclick="startAIAnalysisChat()" id="analyzeButton">Start AI Analysis Chat</button>
                <button type="button" id="aiCredentialsToggle" class="credentials-toggle off" onclick="toggleAICredentialsSaving()">Save Credentials</button>
                <button type="button" onclick="clearAIStoredCredentials()" style="background: #a02020;">Clear Stored Credentials</button>
            </div>
        </form>
    </div>

    <!-- Inline Chat Interface -->
        <div id="inlineChatContainer" class="inline-chat-container" style="display: none;">
            <div class="chat-header">
                <h3>AI Analysis Chat</h3>
                <button class="chat-close-btn" onclick="closeInlineChat()">&times;</button>
            </div>
            <div class="chat-messages-container">
                <div id="inlineChatMessages" class="chat-messages">
                    <!-- Chat messages will be populated here -->
                </div>
                <div id="inlineTypingIndicator" class="typing-indicator" style="display: none;">
                    <span>AI is typing</span>
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>
            <div class="chat-input-container">
                <input type="text" id="inlineChatInput" placeholder="Ask about your Jira data..." onkeypress="handleInlineChatKeyPress(event)">
                <button onclick="sendInlineChatMessage()" id="inlineSendButton">Send</button>
            </div>
        </div>
    </div>
    
    <div id="loadingSection" class="loading" style="display: none;">
        <div class="loading-spinner"></div>
        <p>Loading ticket data from Jira...</p>
    </div>
    
    <div id="errorSection" style="display: none;"></div>
    
    <div id="dashboardContent" style="display: none;">
        <div class="metrics-grid" id="metricsGrid">
            <!-- Metrics will be populated dynamically -->
        </div>
        
        <div class="charts-container">
            <div class="chart-box">
                <h3>Issue Type Distribution</h3>
                <canvas id="issueTypeChart"></canvas>
            </div>
            
            <div class="chart-box">
                <h3>Status Distribution</h3>
                <canvas id="statusChart"></canvas>
            </div>
            
            <div class="chart-box">
                <h3>Priority Distribution</h3>
                <canvas id="priorityChart"></canvas>
            </div>
            
            <div class="chart-box">
                <h3>Resolution Time by Type (Days)</h3>
                <canvas id="resolutionTimeChart"></canvas>
            </div>
        </div>
        
        <div class="insights-section" id="insightsSection">
            <!-- Insights will be populated dynamically -->
        </div>
        
        <div class="insights-section">
            <h2>Team Performance</h2>
            <div class="top-performers" id="performersSection">
                <!-- Performance data will be populated dynamically -->
            </div>
        </div>
    </div>
    
    <!-- Modal for displaying detailed data -->
    <div id="dataModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle">Ticket Details</h2>
            <div class="filter-controls">
                <input type="text" id="searchBox" placeholder="Search tickets..." onkeyup="filterTable()">
                <select id="statusFilter" onchange="filterTable()">
                    <option value="">All Statuses</option>
                </select>
                <select id="typeFilter" onchange="filterTable()">
                    <option value="">All Types</option>
                </select>
                <select id="assigneeFilter" onchange="filterTable()">
                    <option value="">All Assignees</option>
                </select>
            </div>
            <div id="modalContent"></div>
        </div>
    </div>

    <!-- Project List Modal -->
    <div id="projectListModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close" onclick="closeProjectListModal()">&times;</span>
            <h2>Available Projects</h2>
            <div class="project-list-container">
                <div id="projectListContent">
                    <div class="loading-spinner"></div>
                    <p>Loading projects...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Chat Interface Modal -->
    <div id="chatModal" class="modal" style="display: none;">
        <div class="modal-content chat-modal-content">
            <span class="close" onclick="closeChatModal()">&times;</span>
            <h2>AI Analysis Chat</h2>
            <div class="chat-container">
                <div id="chatMessages" class="chat-messages">
                    <!-- Chat messages will be populated here -->
                </div>
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Ask about your Jira data..." onkeypress="handleChatKeyPress(event)">
                    <button onclick="sendChatMessage()" id="sendButton">Send</button>
                </div>
                <div id="typingIndicator" class="typing-indicator" style="display: none;">
                    <span>AI is typing</span>
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allTickets = [];
        let charts = {};
        let apiConfig = {
            baseUrl: '',
            username: '',
            apiToken: '',
            projectKey: ''
        };
        let openaiConfig = {
            apiKey: '',
            model: 'o3'
        };
        let availableProjects = [];
        let selectedProjectIndex = -1;
        let credentialsSaveEnabled = false;
        let availableModels = [
            { name: 'gpt-4o', description: 'GPT-4 Optimized' },
            { name: 'o3', description: 'OpenAI O3' },
            { name: 'o4-mini', description: 'OpenAI O4 Mini' },
            { name: 'o4-mini-high', description: 'OpenAI O4 Mini High' },
            { name: 'gpt-4', description: 'GPT-4' },
            { name: 'gpt-3.5-turbo', description: 'GPT-3.5 Turbo' }
        ];
        let selectedModelIndex = -1;
        
        // Initialize Chart.js defaults
        Chart.defaults.color = '#a8a8b3';

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            loadStoredCredentials();
            setupProjectAutocomplete();
            setupModelAutocomplete();

            // Add chart interactivity test function to window for debugging
            window.testChartInteractivity = function() {
                console.log('Testing chart interactivity...');
                console.log('Charts available:', Object.keys(charts));

                // Test if charts are properly initialized
                Object.entries(charts).forEach(([name, chart]) => {
                    if (chart && chart.options && chart.options.onClick) {
                        console.log(`✓ ${name} chart has onClick handler`);

                        // Test interaction configuration
                        if (chart.options.interaction) {
                            console.log(`✓ ${name} chart has interaction config:`, chart.options.interaction);
                        } else {
                            console.log(`⚠ ${name} chart missing interaction config`);
                        }

                        // Test hover handler
                        if (chart.options.onHover) {
                            console.log(`✓ ${name} chart has onHover handler`);
                        } else {
                            console.log(`⚠ ${name} chart missing onHover handler`);
                        }

                        // Test legend click handler
                        if (chart.options.plugins && chart.options.plugins.legend && chart.options.plugins.legend.onClick) {
                            console.log(`✓ ${name} chart has legend onClick handler`);
                        } else {
                            console.log(`⚠ ${name} chart missing legend onClick handler`);
                        }
                    } else {
                        console.log(`✗ ${name} chart missing onClick handler`);
                    }
                });

                console.log('Chart interactivity test complete. Click on chart elements to test functionality.');
                console.log('Expected behaviors:');
                console.log('- Issue Type Chart: Click segments or legend to filter by type');
                console.log('- Status Chart: Click bars to filter by status');
                console.log('- Priority Chart: Click segments or legend to filter by priority');
                console.log('- Resolution Time Chart: Click bars to show resolved tickets by type');
            };

            // Add modal test function for debugging
            window.testModal = function() {
                console.log('Testing modal functionality...');
                showModal('Test Modal', '<p>This is a test modal. If you can see this, the modal system is working!</p>');
            };

            // Add comprehensive chart interaction test
            window.testAllChartInteractions = function() {
                console.log('🧪 Testing all chart interactions...');

                // Test show functions exist
                const showFunctions = [
                    'showAllTickets', 'showOpenTickets', 'showResolvedTickets',
                    'showTicketsByStatus', 'showTicketsByType', 'showTicketsByPriority',
                    'showTicketsByAssignee', 'showResolvedTicketsByType'
                ];

                showFunctions.forEach(funcName => {
                    if (typeof window[funcName] === 'function') {
                        console.log(`✅ ${funcName} function exists`);
                    } else {
                        console.error(`❌ ${funcName} function missing`);
                    }
                });

                // Test chart canvas elements exist
                const chartIds = ['issueTypeChart', 'statusChart', 'priorityChart', 'resolutionTimeChart'];
                chartIds.forEach(id => {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        console.log(`✅ ${id} canvas element exists`);
                        const style = window.getComputedStyle(canvas);
                        if (style.cursor === 'pointer') {
                            console.log(`✅ ${id} has pointer cursor`);
                        } else {
                            console.warn(`⚠️ ${id} missing pointer cursor`);
                        }
                    } else {
                        console.error(`❌ ${id} canvas element missing`);
                    }
                });

                console.log('🎯 Chart interaction test complete!');
                console.log('💡 Try clicking on chart elements to test functionality');
            };
        });

        // Cookie and credential management
        async function loadStoredCredentials() {
            try {
                const response = await fetch('/api/get-credentials');
                const data = await response.json();
                console.log('Loaded credentials data:', data);

                if (data.baseUrl && data.username && data.hasApiToken) {
                    console.log('Found stored credentials, populating fields');
                    document.getElementById('baseUrl').value = data.baseUrl;
                    document.getElementById('username').value = data.username;

                    // Hide token field and show saved indicator
                    const tokenField = document.getElementById('apiToken');
                    const tokenStatus = document.getElementById('tokenStatus');

                    // Calculate expiration time (1 hour from now, since cookies refresh on access)
                    const expirationTime = new Date(Date.now() + 60 * 60 * 1000);
                    const timeString = expirationTime.toLocaleString();

                    // Hide the input field and show saved status
                    tokenField.style.display = 'none';
                    tokenField.removeAttribute('required'); // Remove required when hidden
                    tokenStatus.style.display = 'block';
                    tokenStatus.innerHTML = `
                        <div style="background: #16213e; border: 1px solid #4ade80; border-radius: 8px; padding: 12px; color: #4ade80;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 16px;">✓</span>
                                <span style="font-weight: 500;">API Token Saved</span>
                            </div>
                            <div style="font-size: 0.85em; color: #a8a8b3; margin-top: 4px;">
                                Valid until ${timeString}
                            </div>
                        </div>
                    `;

                    // Mark that we have stored credentials
                    tokenField.dataset.hasStored = 'true';

                    // Update credentials toggle to "saved" state
                    updateCredentialsToggle('saved');

                    // Set up apiConfig for stored credentials
                    apiConfig = {
                        baseUrl: data.baseUrl,
                        username: data.username,
                        apiToken: '', // Empty - server will use stored token
                        projectKey: '' // Will be set when project is selected
                    };
                    console.log('Set up apiConfig with stored credentials');

                    // Automatically load projects for semantic search since we have valid credentials
                    console.log('Loading projects automatically since credentials are stored');
                    loadProjectsForAutocomplete();

                    // Load cached project key if available
                    loadCachedProjectKey();

                    // Load cached data if available
                    loadCachedDataOnStartup();
                } else {
                    console.log('No stored credentials found, using defaults');
                    // Clear all fields if no stored credentials
                    document.getElementById('baseUrl').value = 'postmanlabs.atlassian.net';
                    document.getElementById('username').value = 'jared.boynton@postman.com';

                    const tokenStatus = document.getElementById('tokenStatus');
                    const tokenField = document.getElementById('apiToken');

                    // Show the input field and hide status
                    tokenField.style.display = 'block';
                    tokenField.setAttribute('required', ''); // Add required when shown
                    tokenStatus.style.display = 'none';
                    tokenField.dataset.hasStored = 'false';
                    tokenField.placeholder = 'Enter your API token';
                    tokenField.value = '';
                    updateCredentialsToggle('off');
                }

                // Handle OpenAI API key and model
                if (data.hasOpenAIKey) {
                    const openaiField = document.getElementById('openaiApiKey');
                    const openaiFieldContainer = openaiField.parentElement;

                    // Hide the input field and show saved indicator
                    openaiField.style.display = 'none';
                    openaiField.dataset.hasStored = 'true';

                    // Create or update saved indicator
                    let savedIndicator = openaiFieldContainer.querySelector('.openai-saved-indicator');
                    if (!savedIndicator) {
                        savedIndicator = document.createElement('div');
                        savedIndicator.className = 'openai-saved-indicator';
                        openaiFieldContainer.appendChild(savedIndicator);
                    }

                    savedIndicator.style.display = 'block';
                    savedIndicator.innerHTML = `
                        <div style="background: #16213e; border: 1px solid #4ade80; border-radius: 8px; padding: 12px; color: #4ade80;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 16px;">✓</span>
                                <span style="font-weight: 500;">OpenAI API Key Saved</span>
                            </div>
                        </div>
                    `;

                    // Set AI credentials toggle to saved state
                    const aiToggle = document.getElementById('aiCredentialsToggle');
                    if (aiToggle) {
                        aiToggle.textContent = 'Credentials Saved';
                        aiToggle.className = 'credentials-toggle saved';
                        aiCredentialsSaveEnabled = true;
                    }
                } else {
                    const openaiField = document.getElementById('openaiApiKey');
                    const openaiFieldContainer = openaiField.parentElement;

                    // Show the input field and hide saved indicator
                    openaiField.style.display = 'block';
                    openaiField.dataset.hasStored = 'false';
                    openaiField.placeholder = 'Enter your OpenAI API key';
                    openaiField.value = '';

                    // Hide saved indicator if it exists
                    const savedIndicator = openaiFieldContainer.querySelector('.openai-saved-indicator');
                    if (savedIndicator) {
                        savedIndicator.style.display = 'none';
                    }

                    // Reset AI credentials toggle
                    const aiToggle = document.getElementById('aiCredentialsToggle');
                    if (aiToggle) {
                        aiToggle.textContent = 'Save Credentials';
                        aiToggle.className = 'credentials-toggle off';
                        aiCredentialsSaveEnabled = false;
                    }
                }

                // Handle OpenAI model
                if (data.openaiModel) {
                    document.getElementById('openaiModel').value = data.openaiModel;
                } else {
                    document.getElementById('openaiModel').value = 'o3';
                }

            } catch (error) {
                console.log('No stored credentials found');
                const tokenStatus = document.getElementById('tokenStatus');
                const tokenField = document.getElementById('apiToken');
                const openaiField = document.getElementById('openaiApiKey');

                tokenStatus.style.display = 'none';
                tokenField.dataset.hasStored = 'false';
                tokenField.placeholder = 'Enter your API token';
                openaiField.dataset.hasStored = 'false';
                openaiField.placeholder = 'Enter your OpenAI API key';
                updateCredentialsToggle('off');
            }
        }

        async function toggleCredentialsSaving() {
            const toggle = document.getElementById('credentialsToggle');

            if (toggle.classList.contains('validating')) {
                return; // Don't allow clicking if currently validating
            }

            // Always validate and save credentials (overrides existing ones if valid)
            await validateAndSaveCredentials();
        }

        function updateCredentialsToggle(state) {
            const toggle = document.getElementById('credentialsToggle');

            toggle.classList.remove('off', 'on', 'saved', 'error', 'validating');

            switch (state) {
                case 'off':
                    toggle.classList.add('off');
                    toggle.textContent = 'Save Credentials';
                    credentialsSaveEnabled = false;
                    break;
                case 'validating':
                    toggle.classList.add('validating');
                    toggle.textContent = 'Validating...';
                    break;
                case 'saved':
                    toggle.classList.add('saved');
                    toggle.textContent = 'Credentials Saved';
                    credentialsSaveEnabled = false;
                    break;
                case 'error':
                    toggle.classList.add('error');
                    toggle.textContent = 'Invalid Credentials';
                    credentialsSaveEnabled = false;
                    break;
            }
        }

        async function validateAndSaveCredentials() {
            const baseUrl = document.getElementById('baseUrl').value.trim();
            const username = document.getElementById('username').value.trim();
            const apiTokenField = document.getElementById('apiToken');

            // Get API token from input field (works even when field is hidden)
            let apiToken = apiTokenField.value.trim();

            // If the field is hidden (credentials saved) but user wants to update,
            // we need to prompt for new credentials
            if (!apiToken && apiTokenField.style.display === 'none') {
                // Show the input field temporarily for new credential entry
                apiTokenField.style.display = 'block';
                apiTokenField.setAttribute('required', ''); // Add required when shown
                const tokenStatus = document.getElementById('tokenStatus');
                tokenStatus.style.display = 'none';
                apiTokenField.placeholder = 'Enter new API token to update';
                apiTokenField.focus();
                updateCredentialsToggle('off');
                return;
            }

            // Validate required fields
            if (!baseUrl || !username || !apiToken) {
                updateCredentialsToggle('error');
                setTimeout(() => updateCredentialsToggle('off'), 3000);
                return;
            }

            // Show validating state
            updateCredentialsToggle('validating');

            try {
                // Test the credentials by making a simple API call
                const testResponse = await fetch('/api/test-credentials', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        baseUrl,
                        username,
                        apiToken
                    })
                });

                if (testResponse.ok) {
                    // Credentials are valid, now store them
                    const storeResponse = await fetch('/api/store-credentials', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            baseUrl,
                            username,
                            apiToken
                        })
                    });

                    if (storeResponse.ok) {
                        updateCredentialsToggle('saved');
                        // Update the UI to show saved state
                        loadStoredCredentials();
                    } else {
                        throw new Error('Failed to store credentials');
                    }
                } else {
                    // Invalid credentials
                    updateCredentialsToggle('error');
                    setTimeout(() => updateCredentialsToggle('off'), 3000);
                }
            } catch (error) {
                console.error('Credential validation error:', error);
                updateCredentialsToggle('error');
                setTimeout(() => updateCredentialsToggle('off'), 3000);
            }
        }

        async function storeCredentials() {
            try {
                await fetch('/api/store-credentials', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        baseUrl: apiConfig.baseUrl,
                        username: apiConfig.username,
                        apiToken: apiConfig.apiToken,
                        openaiApiKey: document.getElementById('openaiApiKey').value,
                        rememberMe: credentialsSaveEnabled
                    })
                });

                // Update toggle to saved state
                updateCredentialsToggle('saved');
            } catch (error) {
                console.error('Failed to store credentials:', error);
            }
        }

        async function clearStoredCredentials() {
            try {
                await fetch('/api/clear-credentials', {
                    method: 'POST'
                });

                // Clear form fields
                document.getElementById('baseUrl').value = 'postmanlabs.atlassian.net';
                document.getElementById('username').value = 'jared.boynton@postman.com';

                const tokenField = document.getElementById('apiToken');
                const tokenStatus = document.getElementById('tokenStatus');
                const openaiField = document.getElementById('openaiApiKey');

                // Show API token field and hide status
                tokenField.style.display = 'block';
                tokenField.setAttribute('required', ''); // Add required when shown
                tokenField.value = '';
                tokenField.placeholder = 'Enter your API token';
                tokenField.dataset.hasStored = 'false';
                tokenStatus.style.display = 'none';

                // Show OpenAI field and hide saved indicator
                openaiField.style.display = 'block';
                openaiField.value = '';
                openaiField.placeholder = 'Enter your OpenAI API key';
                openaiField.dataset.hasStored = 'false';

                // Hide OpenAI saved indicator if it exists
                const openaiFieldContainer = openaiField.parentElement;
                const savedIndicator = openaiFieldContainer.querySelector('.openai-saved-indicator');
                if (savedIndicator) {
                    savedIndicator.style.display = 'none';
                }

                document.getElementById('projectKey').value = '';

                // Clear cached data since credentials changed
                clearJiraDataCache();

                // Reset toggle button
                updateCredentialsToggle('off');

                alert('Stored credentials cleared successfully');
            } catch (error) {
                console.error('Failed to clear credentials:', error);
                alert('Failed to clear credentials');
            }
        }

        // Project Key caching functions
        function loadCachedProjectKey() {
            try {
                const cachedProjectKey = localStorage.getItem('jira_last_project_key');
                if (cachedProjectKey) {
                    console.log('Loading cached project key:', cachedProjectKey);
                    document.getElementById('projectKey').value = cachedProjectKey;
                }
            } catch (error) {
                console.error('Error loading cached project key:', error);
            }
        }

        function cacheProjectKey(projectKey) {
            try {
                if (projectKey && projectKey.trim()) {
                    localStorage.setItem('jira_last_project_key', projectKey.trim());
                    console.log('Cached project key:', projectKey.trim());
                }
            } catch (error) {
                console.error('Error caching project key:', error);
            }
        }

        // Data caching functions
        function cacheJiraData(data, projectKey) {
            try {
                const cacheData = {
                    data: data,
                    projectKey: projectKey,
                    timestamp: Date.now(),
                    apiConfig: {
                        baseUrl: apiConfig.baseUrl,
                        username: apiConfig.username
                    }
                };
                localStorage.setItem('jira_cached_data', JSON.stringify(cacheData));
                console.log('Cached Jira data for project:', projectKey);
            } catch (error) {
                console.error('Error caching Jira data:', error);
            }
        }

        function loadCachedJiraData() {
            try {
                const cachedDataStr = localStorage.getItem('jira_cached_data');
                if (!cachedDataStr) {
                    return null;
                }

                const cachedData = JSON.parse(cachedDataStr);

                // Check if cache is less than 1 hour old
                const cacheAge = Date.now() - cachedData.timestamp;
                const maxCacheAge = 60 * 60 * 1000; // 1 hour

                if (cacheAge > maxCacheAge) {
                    console.log('Cached data is too old, ignoring');
                    localStorage.removeItem('jira_cached_data');
                    return null;
                }

                // Check if cached data matches current API config
                if (cachedData.apiConfig.baseUrl !== apiConfig.baseUrl ||
                    cachedData.apiConfig.username !== apiConfig.username) {
                    console.log('Cached data is for different credentials, ignoring');
                    localStorage.removeItem('jira_cached_data');
                    return null;
                }

                console.log('Loading cached Jira data for project:', cachedData.projectKey);
                return cachedData;
            } catch (error) {
                console.error('Error loading cached Jira data:', error);
                localStorage.removeItem('jira_cached_data');
                return null;
            }
        }

        function clearJiraDataCache() {
            try {
                localStorage.removeItem('jira_cached_data');
                console.log('Cleared Jira data cache');
            } catch (error) {
                console.error('Error clearing Jira data cache:', error);
            }
        }

        function loadCachedDataOnStartup() {
            const cachedData = loadCachedJiraData();
            if (cachedData) {
                // Set the project key from cache
                document.getElementById('projectKey').value = cachedData.projectKey;

                // Update apiConfig with cached project key
                if (apiConfig) {
                    apiConfig.projectKey = cachedData.projectKey;
                }

                // Process the cached data
                processJiraData(cachedData.data);

                // Show the dashboard
                document.getElementById('loadingSection').style.display = 'none';
                document.getElementById('dashboardContent').style.display = 'block';

                // Update the Load Data button to indicate cached data is shown
                const loadButton = document.querySelector('.load-data-btn');
                const originalText = loadButton.textContent;
                loadButton.textContent = 'Refresh Data';
                loadButton.title = 'Click to load fresh data from Jira';

                console.log('Displayed cached data for project:', cachedData.projectKey);
            }
        }

        // Load projects for autocomplete (background loading)
        async function loadProjectsForAutocomplete() {
            try {
                console.log('Loading projects for autocomplete...');

                // Fetch regular Jira projects (rely on server-side cookie credentials)
                const regularProjectsPromise = fetch('/api/jira-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        endpoint: '/rest/api/3/project',
                        method: 'GET'
                    })
                });

                // Fetch service desk projects (rely on server-side cookie credentials)
                const serviceDeskProjectsPromise = fetch('/api/jira-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        endpoint: '/rest/servicedeskapi/servicedesk',
                        method: 'GET'
                    })
                });

                const [regularResponse, serviceDeskResponse] = await Promise.allSettled([
                    regularProjectsPromise,
                    serviceDeskProjectsPromise
                ]);

                availableProjects = []; // Reset the projects array

                // Process regular projects
                if (regularResponse.status === 'fulfilled' && regularResponse.value.ok) {
                    const regularProjects = await regularResponse.value.json();
                    if (regularProjects.length > 0) {
                        regularProjects.forEach(project => {
                            availableProjects.push({
                                key: project.key,
                                name: project.name,
                                type: 'Project'
                            });
                        });
                    }
                }

                // Process service desk projects
                if (serviceDeskResponse.status === 'fulfilled' && serviceDeskResponse.value.ok) {
                    const serviceDeskData = await serviceDeskResponse.value.json();
                    const serviceDesks = serviceDeskData.values || [];
                    if (serviceDesks.length > 0) {
                        serviceDesks.forEach(desk => {
                            availableProjects.push({
                                key: desk.projectKey,
                                name: desk.projectName,
                                type: 'Service Desk'
                            });
                        });
                    }
                }

                console.log(`Loaded ${availableProjects.length} projects for autocomplete`);

            } catch (error) {
                console.error('Error loading projects for autocomplete:', error);
            }
        }

        // Project autocomplete setup
        function setupProjectAutocomplete() {
            const input = document.getElementById('projectKey');
            const dropdown = document.getElementById('projectDropdown');

            input.addEventListener('input', function() {
                const query = this.value.toLowerCase();
                if (query.length === 0) {
                    dropdown.style.display = 'none';
                    return;
                }

                const filtered = availableProjects.filter(project =>
                    project.key.toLowerCase().includes(query) ||
                    project.name.toLowerCase().includes(query)
                );

                showProjectDropdown(filtered);
            });

            input.addEventListener('keydown', function(e) {
                const items = dropdown.querySelectorAll('.autocomplete-item');

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedProjectIndex = Math.min(selectedProjectIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedProjectIndex = Math.max(selectedProjectIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedProjectIndex >= 0 && items[selectedProjectIndex]) {
                        selectProject(items[selectedProjectIndex].dataset.key);
                    }
                } else if (e.key === 'Escape') {
                    dropdown.style.display = 'none';
                    selectedProjectIndex = -1;
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                    selectedProjectIndex = -1;
                }
            });
        }

        function showProjectDropdown(projects) {
            const dropdown = document.getElementById('projectDropdown');

            if (projects.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            dropdown.innerHTML = projects.map((project, index) =>
                `<div class="autocomplete-item" data-key="${project.key}" onclick="selectProject('${project.key}')">
                    <strong>${project.key}</strong> - ${project.name}
                    <span class="project-type">${project.type || 'Project'}</span>
                </div>`
            ).join('');

            dropdown.style.display = 'block';
            selectedProjectIndex = -1;
        }

        function updateSelection(items) {
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === selectedProjectIndex);
            });

            if (selectedProjectIndex >= 0 && items[selectedProjectIndex]) {
                items[selectedProjectIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectProject(projectKey) {
            document.getElementById('projectKey').value = projectKey;
            document.getElementById('projectDropdown').style.display = 'none';
            selectedProjectIndex = -1;
        }

        // Model autocomplete setup
        function setupModelAutocomplete() {
            const input = document.getElementById('openaiModel');
            const dropdown = document.getElementById('modelDropdown');

            input.addEventListener('input', function() {
                const query = this.value.toLowerCase();
                if (query.length === 0) {
                    dropdown.style.display = 'none';
                    return;
                }

                const filtered = availableModels.filter(model =>
                    model.name.toLowerCase().includes(query) ||
                    model.description.toLowerCase().includes(query)
                );

                showModelDropdown(filtered);
            });

            input.addEventListener('keydown', function(e) {
                const items = dropdown.querySelectorAll('.autocomplete-item');

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedModelIndex = Math.min(selectedModelIndex + 1, items.length - 1);
                    updateModelSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedModelIndex = Math.max(selectedModelIndex - 1, -1);
                    updateModelSelection(items);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedModelIndex >= 0 && items[selectedModelIndex]) {
                        selectModel(items[selectedModelIndex].dataset.name);
                    }
                } else if (e.key === 'Escape') {
                    dropdown.style.display = 'none';
                    selectedModelIndex = -1;
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                    selectedModelIndex = -1;
                }
            });
        }

        function showModelDropdown(models) {
            const dropdown = document.getElementById('modelDropdown');

            if (models.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            dropdown.innerHTML = models.map((model, index) =>
                `<div class="autocomplete-item" data-name="${model.name}" onclick="selectModel('${model.name}')">
                    <strong>${model.name}</strong> - ${model.description}
                </div>`
            ).join('');

            dropdown.style.display = 'block';
            selectedModelIndex = -1;
        }

        function updateModelSelection(items) {
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === selectedModelIndex);
            });

            if (selectedModelIndex >= 0 && items[selectedModelIndex]) {
                items[selectedModelIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectModel(modelName) {
            document.getElementById('openaiModel').value = modelName;
            document.getElementById('modelDropdown').style.display = 'none';
            selectedModelIndex = -1;
        }

        // Configuration management
        function updateConfig(event) {
            event.preventDefault();

            const tokenField = document.getElementById('apiToken');
            const hasStoredToken = tokenField.dataset.hasStored === 'true';
            const enteredToken = tokenField.value;

            // Validate required fields
            const baseUrl = document.getElementById('baseUrl').value;
            const username = document.getElementById('username').value;
            const projectKey = document.getElementById('projectKey').value;

            if (!baseUrl || !username || !projectKey) {
                alert('Please fill in all required fields.');
                return;
            }

            // Check API token - either entered or stored
            if (!enteredToken && !hasStoredToken) {
                alert('Please enter your API token or use stored credentials.');
                return;
            }

            apiConfig = {
                baseUrl: baseUrl,
                username: username,
                apiToken: enteredToken, // Will be empty if using stored token, server will use stored one
                projectKey: projectKey
            };

            // Store credentials if toggle is enabled and token is provided
            if (credentialsSaveEnabled && enteredToken) {
                storeCredentials();
            }

            fetchJiraData();
        }
        
        // Project List Modal Functions
        function showProjectListModal() {
            const modal = document.getElementById('projectListModal');
            modal.style.display = 'block';
            loadProjectsInModal();
        }

        function closeProjectListModal() {
            const modal = document.getElementById('projectListModal');
            modal.style.display = 'none';
        }

        // Click outside to close modal
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('projectListModal');
            if (event.target === modal) {
                closeProjectListModal();
            }
        });

        async function loadProjectsInModal() {
            const contentDiv = document.getElementById('projectListContent');
            contentDiv.innerHTML = '<div class="loading-spinner"></div><p>Loading projects...</p>';

            try {
                // Fetch regular Jira projects (rely on server-side cookie credentials)
                const regularProjectsPromise = fetch('/api/jira-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        endpoint: '/rest/api/3/project',
                        params: {}
                    })
                });

                // Fetch Service Desk projects (rely on server-side cookie credentials)
                const serviceDeskProjectsPromise = fetch('/api/jira-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        endpoint: '/rest/servicedeskapi/servicedesk',
                        params: {}
                    })
                });

                // Wait for both requests
                const [regularResponse, serviceDeskResponse] = await Promise.allSettled([
                    regularProjectsPromise,
                    serviceDeskProjectsPromise
                ]);

                let projectHtml = '';
                let hasProjects = false;
                availableProjects = []; // Reset the projects array

                // Process regular projects
                if (regularResponse.status === 'fulfilled' && regularResponse.value.ok) {
                    const regularProjects = await regularResponse.value.json();
                    if (regularProjects.length > 0) {
                        projectHtml += '<div class="project-category"><h4>Regular Jira Projects</h4>';
                        regularProjects.forEach(project => {
                            projectHtml += `
                                <div class="project-item" onclick="selectProjectFromModal('${project.key}')">
                                    <span class="project-key">${project.key}</span>
                                    ${project.name}
                                    <span class="project-type-badge">Project</span>
                                </div>
                            `;
                            availableProjects.push({
                                key: project.key,
                                name: project.name,
                                type: 'Project'
                            });
                            hasProjects = true;
                        });
                        projectHtml += '</div>';
                    }
                }

                // Process Service Desk projects
                if (serviceDeskResponse.status === 'fulfilled' && serviceDeskResponse.value.ok) {
                    const serviceDeskData = await serviceDeskResponse.value.json();
                    const serviceDesks = serviceDeskData.values || [];
                    if (serviceDesks.length > 0) {
                        projectHtml += '<div class="project-category"><h4>Service Desk Projects</h4>';
                        serviceDesks.forEach(desk => {
                            projectHtml += `
                                <div class="project-item" onclick="selectProjectFromModal('${desk.projectKey}')">
                                    <span class="project-key">${desk.projectKey}</span>
                                    ${desk.projectName}
                                    <span class="project-type-badge">Service Desk</span>
                                </div>
                            `;
                            availableProjects.push({
                                key: desk.projectKey,
                                name: desk.projectName,
                                type: 'Service Desk'
                            });
                            hasProjects = true;
                        });
                        projectHtml += '</div>';
                    }
                }

                if (!hasProjects) {
                    projectHtml = '<p style="text-align: center; color: #888; padding: 40px;">No projects found. Make sure your API token has the necessary permissions.</p>';
                }

                contentDiv.innerHTML = projectHtml;

            } catch (error) {
                contentDiv.innerHTML = `<div class="error-message">Error fetching projects: ${error.message}</div>`;
                console.error('Error fetching projects:', error);
            }
        }

        function selectProjectFromModal(projectKey) {
            document.getElementById('projectKey').value = projectKey;
            closeProjectListModal();
        }

        // Legacy function for backward compatibility
        async function listProjects() {
            showProjectListModal();
        }

        // Chat Interface Functions
        let chatHistory = [];
        let isAITyping = false;

        function openChatInterface() {
            const apiKey = document.getElementById('openaiApiKey').value;
            const model = document.getElementById('openaiModel').value;

            if (!apiKey) {
                alert('Please enter your OpenAI API key');
                return;
            }

            if (allTickets.length === 0) {
                alert('Please load Jira data first');
                return;
            }

            openaiConfig.apiKey = apiKey;
            openaiConfig.model = model;

            const modal = document.getElementById('chatModal');
            modal.style.display = 'block';

            // Initialize chat if empty
            if (chatHistory.length === 0) {
                initializeChat();
            }
        }

        function closeChatModal() {
            const modal = document.getElementById('chatModal');
            modal.style.display = 'none';
        }

        // Click outside to close chat modal
        window.addEventListener('click', function(event) {
            const chatModal = document.getElementById('chatModal');
            if (event.target === chatModal) {
                closeChatModal();
            }
        });

        function initializeChat() {
            chatHistory = [];
            const messagesContainer = document.getElementById('chatMessages');
            messagesContainer.innerHTML = '';

            // Add initial AI message
            const initialMessage = `Hello! I'm ready to analyze your Jira project data. I can help you understand:

• **Performance trends** and bottlenecks
• **Team productivity** insights
• **Issue patterns** and recommendations
• **Resolution time** analysis
• **Priority distribution** and workload balance

What would you like to explore about your ${allTickets.length} tickets?`;

            addMessage('ai', initialMessage);
        }

        function addMessage(sender, content, timestamp = null) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `message-bubble ${sender}`;

            if (sender === 'ai') {
                bubbleDiv.innerHTML = renderMarkdown(content);
            } else {
                bubbleDiv.textContent = content;
            }

            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = formatTimestamp(timestamp || new Date());

            messageDiv.appendChild(bubbleDiv);
            messageDiv.appendChild(timestampDiv);
            messagesContainer.appendChild(messageDiv);

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Store in history
            chatHistory.push({
                sender,
                content,
                timestamp: timestamp || new Date()
            });
        }

        function formatTimestamp(date) {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function displayTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            indicator.style.display = 'flex';
            isAITyping = true;
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            indicator.style.display = 'none';
            isAITyping = false;
        }

        function renderMarkdown(text) {
            // Enhanced markdown rendering with code blocks and improved lists
            let html = text;

            // Handle code blocks first (```code```)
            html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');

            // Handle inline code (`code`)
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

            // Handle headers
            html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');

            // Handle bold and italic
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

            // Handle unordered lists (- or •)
            html = html.replace(/^[-•] (.*$)/gm, '<li>$1</li>');

            // Handle numbered lists
            html = html.replace(/^\d+\. (.*$)/gm, '<li>$1</li>');

            // Wrap consecutive list items in ul/ol tags
            html = html.replace(/(<li>.*<\/li>)/gs, function(match) {
                // Check if it's a numbered list by looking for numbers
                if (text.match(/^\d+\./m)) {
                    return '<ol>' + match + '</ol>';
                } else {
                    return '<ul>' + match + '</ul>';
                }
            });

            // Handle line breaks (but not inside code blocks)
            html = html.replace(/\n(?!<\/?(pre|code|ul|ol|li))/g, '<br>');

            return html;
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Interactive chat AI integration
        async function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();

            if (!message) return;

            // Clear input
            chatInput.value = '';

            // Add user message to chat
            addMessage('user', message);

            // Show typing indicator
            displayTypingIndicator(true);

            try {
                // Prepare context data for AI
                const contextData = {
                    totalIssues: allTickets ? allTickets.length : 0,
                    projectKey: apiConfig.projectKey,
                    recentIssues: allTickets ? allTickets.slice(0, 10).map(ticket => ({
                        key: ticket.key,
                        summary: ticket.summary,
                        status: ticket.status,
                        priority: ticket.priority,
                        type: ticket.type,
                        created: ticket.created
                    })) : []
                };

                // Get conversation history for context
                const chatMessages = document.getElementById('chatMessages');
                const previousMessages = Array.from(chatMessages.children)
                    .filter(msg => msg.classList.contains('message'))
                    .slice(-6) // Last 6 messages for context
                    .map(msg => ({
                        role: msg.classList.contains('user-message') ? 'user' : 'assistant',
                        content: msg.querySelector('.message-content').textContent
                    }));

                // Prepare messages for OpenAI
                const messages = [
                    {
                        role: 'system',
                        content: `You are a Jira analytics assistant. You have access to project data: ${JSON.stringify(contextData)}.
                        Provide helpful insights about the Jira project data. Be concise and actionable in your responses.
                        If asked about specific tickets, reference the data provided. Format responses with markdown for better readability.`
                    },
                    ...previousMessages,
                    {
                        role: 'user',
                        content: message
                    }
                ];

                // Make API call to OpenAI through proxy
                const requestBody = {
                    model: openaiConfig.model || 'o3',
                    messages: messages
                };

                // Only include apiKey if we have one (not using stored credentials)
                if (openaiConfig.apiKey) {
                    requestBody.apiKey = openaiConfig.apiKey;
                }

                const response = await fetch('/api/openai-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Hide typing indicator
                displayTypingIndicator(false);

                // Add AI response to chat
                addMessage('ai', data.content);

            } catch (error) {
                console.error('Chat error:', error);
                displayTypingIndicator(false);
                addMessage('ai', 'Sorry, I encountered an error while processing your request. Please check your OpenAI API configuration and try again.');
            }
        }

        // AI Credentials Management
        let aiCredentialsSaveEnabled = false;

        async function toggleAICredentialsSaving() {
            const toggle = document.getElementById('aiCredentialsToggle');

            if (toggle.classList.contains('validating')) {
                return; // Don't allow clicking if currently validating
            }

            // Always validate and save AI credentials (overrides existing ones if valid)
            await validateAndSaveAICredentials();
        }

        function updateAICredentialsToggle(state) {
            const toggle = document.getElementById('aiCredentialsToggle');

            toggle.classList.remove('off', 'on', 'saved', 'error', 'validating');

            switch (state) {
                case 'off':
                    toggle.classList.add('off');
                    toggle.textContent = 'Save Credentials';
                    aiCredentialsSaveEnabled = false;
                    break;
                case 'validating':
                    toggle.classList.add('validating');
                    toggle.textContent = 'Validating...';
                    break;
                case 'saved':
                    toggle.classList.add('saved');
                    toggle.textContent = 'Credentials Saved';
                    aiCredentialsSaveEnabled = false;
                    break;
                case 'error':
                    toggle.classList.add('error');
                    toggle.textContent = 'Invalid API Key';
                    aiCredentialsSaveEnabled = false;
                    break;
            }
        }

        async function validateAndSaveAICredentials() {
            const openaiField = document.getElementById('openaiApiKey');
            const model = document.getElementById('openaiModel').value.trim();

            // Get API key from input field (works even when field is hidden)
            let apiKey = openaiField.value.trim();

            // If the field is hidden (credentials saved) but user wants to update,
            // we need to prompt for new credentials
            if (!apiKey && openaiField.style.display === 'none') {
                // Show the input field temporarily for new credential entry
                openaiField.style.display = 'block';
                const openaiFieldContainer = openaiField.parentElement;
                const savedIndicator = openaiFieldContainer.querySelector('.openai-saved-indicator');
                if (savedIndicator) {
                    savedIndicator.style.display = 'none';
                }
                openaiField.placeholder = 'Enter new OpenAI API key to update';
                openaiField.focus();
                updateAICredentialsToggle('off');
                return;
            }

            // Validate required fields
            if (!apiKey) {
                updateAICredentialsToggle('error');
                setTimeout(() => updateAICredentialsToggle('off'), 3000);
                return;
            }

            // Show validating state
            updateAICredentialsToggle('validating');

            try {
                // Test the OpenAI API key by making a simple API call
                const testResponse = await fetch('/api/test-openai-credentials', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        apiKey,
                        model
                    })
                });

                if (testResponse.ok) {
                    // API key is valid, now store it
                    const storeResponse = await fetch('/api/store-ai-credentials', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            apiKey,
                            model
                        })
                    });

                    if (storeResponse.ok) {
                        updateAICredentialsToggle('saved');
                        // Update the UI to show saved state
                        loadStoredCredentials();
                    } else {
                        throw new Error('Failed to store AI credentials');
                    }
                } else {
                    // Invalid API key
                    updateAICredentialsToggle('error');
                    setTimeout(() => updateAICredentialsToggle('off'), 3000);
                }
            } catch (error) {
                console.error('AI credential validation error:', error);
                updateAICredentialsToggle('error');
                setTimeout(() => updateAICredentialsToggle('off'), 3000);
            }
        }

        async function storeAICredentials() {
            try {
                const apiKey = document.getElementById('openaiApiKey').value;
                const model = document.getElementById('openaiModel').value;

                await fetch('/api/store-credentials', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        openaiApiKey: apiKey,
                        openaiModel: model,
                        rememberMe: true
                    })
                });

                console.log('AI credentials stored successfully');
            } catch (error) {
                console.error('Failed to store AI credentials:', error);
            }
        }

        async function clearAIStoredCredentials() {
            try {
                await fetch('/api/clear-credentials', {
                    method: 'POST'
                });

                // Clear form fields and show input field
                const openaiField = document.getElementById('openaiApiKey');
                openaiField.style.display = 'block';
                openaiField.value = '';
                openaiField.placeholder = 'Enter your OpenAI API key';
                openaiField.dataset.hasStored = 'false';

                document.getElementById('openaiModel').value = 'o3';

                // Hide saved indicator if it exists
                const openaiFieldContainer = openaiField.parentElement;
                const savedIndicator = openaiFieldContainer.querySelector('.openai-saved-indicator');
                if (savedIndicator) {
                    savedIndicator.style.display = 'none';
                }

                // Reset toggle
                const toggle = document.getElementById('aiCredentialsToggle');
                toggle.textContent = 'Save Credentials';
                toggle.className = 'credentials-toggle off';
                aiCredentialsSaveEnabled = false;

                alert('AI credentials cleared successfully');
            } catch (error) {
                console.error('Failed to clear AI credentials:', error);
                alert('Failed to clear credentials');
            }
        }

        async function startAIAnalysisChat() {
            // First try to get API key from input field
            let apiKey = document.getElementById('openaiApiKey').value;
            let model = document.getElementById('openaiModel').value;

            // If no API key in input field, check for stored credentials
            if (!apiKey) {
                try {
                    const response = await fetch('/api/get-credentials');
                    const data = await response.json();

                    if (data.hasOpenAIKey) {
                        // Use stored credentials
                        console.log('Using stored OpenAI credentials');
                        apiKey = 'stored'; // Placeholder - actual key is in cookies
                        if (data.openaiModel) {
                            model = data.openaiModel;
                        }
                    }
                } catch (error) {
                    console.error('Error checking stored credentials:', error);
                }
            }

            if (!apiKey) {
                alert('Please enter your OpenAI API key or save your credentials first');
                return;
            }

            // Store credentials if toggle is enabled and we have a real API key (not using stored)
            if (aiCredentialsSaveEnabled && apiKey !== 'stored') {
                storeAICredentials();
            }

            // Set config - if using stored credentials, the server will handle the API key
            openaiConfig.apiKey = apiKey === 'stored' ? null : apiKey;
            openaiConfig.model = model;

            // Show inline chat
            const chatContainer = document.getElementById('inlineChatContainer');
            chatContainer.style.display = 'flex';

            // Initialize chat if empty
            const chatMessages = document.getElementById('inlineChatMessages');
            if (chatMessages.children.length === 0) {
                const initialMessage = `Hello! I'm your Jira analytics assistant. I can help you analyze your project data and provide insights about:

• **Issue patterns** and trends
• **Team performance** and workload distribution
• **Status transitions** and bottlenecks
• **Resolution time** analysis
• **Priority distribution** and workload balance

What would you like to explore about your ${allTickets ? allTickets.length : 0} tickets?`;

                addInlineMessage('ai', initialMessage);
            }

            // Scroll to chat
            chatContainer.scrollIntoView({ behavior: 'smooth' });
        }

        function closeInlineChat() {
            const chatContainer = document.getElementById('inlineChatContainer');
            chatContainer.style.display = 'none';
        }

        // Inline Chat Functions
        function addInlineMessage(sender, content, timestamp = null) {
            const messagesContainer = document.getElementById('inlineChatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `message-bubble ${sender}`;

            if (sender === 'ai') {
                bubbleDiv.innerHTML = renderMarkdown(content);
            } else {
                bubbleDiv.textContent = content;
            }

            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'message-timestamp';
            timestampDiv.textContent = timestamp || formatTimestamp(new Date());

            messageDiv.appendChild(bubbleDiv);
            messageDiv.appendChild(timestampDiv);
            messagesContainer.appendChild(messageDiv);

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function handleInlineChatKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendInlineChatMessage();
            }
        }

        async function sendInlineChatMessage() {
            const chatInput = document.getElementById('inlineChatInput');
            const message = chatInput.value.trim();

            if (!message) return;

            // Clear input
            chatInput.value = '';

            // Add user message to chat
            addInlineMessage('user', message);

            // Show typing indicator
            displayInlineTypingIndicator(true);

            try {
                // Prepare context data for AI
                const contextData = {
                    totalIssues: allTickets ? allTickets.length : 0,
                    projectKey: apiConfig.projectKey,
                    recentIssues: allTickets ? allTickets.slice(0, 10).map(ticket => ({
                        key: ticket.key,
                        summary: ticket.summary,
                        description: ticket.description,
                        status: ticket.status,
                        priority: ticket.priority,
                        type: ticket.type,
                        created: ticket.created,
                        assignee: ticket.assignee,
                        reporter: ticket.reporter,
                        components: ticket.components,
                        labels: ticket.labels,
                        comments: ticket.comments,
                        commentCount: ticket.commentCount
                    })) : []
                };

                // Get conversation history for context
                const chatMessages = document.getElementById('inlineChatMessages');
                const previousMessages = Array.from(chatMessages.children)
                    .filter(msg => msg.classList.contains('chat-message'))
                    .slice(-6) // Last 6 messages for context
                    .map(msg => ({
                        role: msg.classList.contains('user') ? 'user' : 'assistant',
                        content: msg.querySelector('.message-bubble').textContent
                    }));

                // Prepare messages for OpenAI
                const messages = [
                    {
                        role: 'system',
                        content: `You are a Jira analytics assistant. You have access to project data: ${JSON.stringify(contextData)}.
                        Provide helpful insights about the Jira project data. Be concise and actionable in your responses.

                        IMPORTANT: When discussing specific tickets, ALWAYS include:
                        - **Reporter**: Who reported the issue
                        - **Assignee**: Who is assigned to work on it
                        - **Customer**: Check components, labels, or reporter field for customer information
                        - **Comment History**: Include relevant comments and their authors when available

                        Format responses with markdown for better readability. Use bullet points and clear structure.`
                    },
                    ...previousMessages,
                    {
                        role: 'user',
                        content: message
                    }
                ];

                // Make API call to OpenAI through proxy
                const requestBody = {
                    model: openaiConfig.model || 'o3',
                    messages: messages
                };

                // Only include apiKey if we have one (not using stored credentials)
                if (openaiConfig.apiKey) {
                    requestBody.apiKey = openaiConfig.apiKey;
                }

                const response = await fetch('/api/openai-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Hide typing indicator
                displayInlineTypingIndicator(false);

                // Add AI response to chat
                addInlineMessage('ai', data.content);

            } catch (error) {
                console.error('Inline chat error:', error);
                displayInlineTypingIndicator(false);
                addInlineMessage('ai', 'Sorry, I encountered an error while processing your request. Please check your OpenAI API configuration and try again.');
            }
        }

        function displayInlineTypingIndicator(show) {
            const indicator = document.getElementById('inlineTypingIndicator');
            if (show) {
                indicator.style.display = 'flex';
            } else {
                indicator.style.display = 'none';
            }
        }

        // Fetch data from Jira API through proxy
        async function fetchJiraData() {
            const loadingSection = document.getElementById('loadingSection');
            const errorSection = document.getElementById('errorSection');
            const dashboardContent = document.getElementById('dashboardContent');
            
            loadingSection.style.display = 'block';
            errorSection.style.display = 'none';
            dashboardContent.style.display = 'none';
            
            try {
                // Get project key from form and update apiConfig
                const projectKey = document.getElementById('projectKey').value.trim();
                if (!projectKey) {
                    throw new Error('Please enter a project key');
                }

                apiConfig.projectKey = projectKey;

                // Cache the project key for future use
                cacheProjectKey(projectKey);

                // Construct JQL query for the selected project
                const jql = `project = ${projectKey} ORDER BY created DESC`;
                const maxResults = 1000; // Adjust as needed
                
                // Use proxy endpoint to avoid CORS issues
                const requestBody = {
                    endpoint: '/rest/api/3/search',
                    params: {
                        jql: jql,
                        maxResults: maxResults,
                        expand: 'changelog,comments',
                        fields: 'summary,description,issuetype,status,priority,assignee,reporter,created,resolutiondate,components,labels,project,comment'
                    }
                };

                // Only include credentials if we have them (otherwise server will use stored ones)
                if (apiConfig.baseUrl && apiConfig.username && apiConfig.apiToken) {
                    requestBody.baseUrl = apiConfig.baseUrl;
                    requestBody.username = apiConfig.username;
                    requestBody.apiToken = apiConfig.apiToken;
                }

                const response = await fetch('/api/jira-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(`API request failed: ${response.status} - ${error.error || error.details || response.statusText}`);
                }
                
                const data = await response.json();

                // Cache the data for future use
                cacheJiraData(data.issues, apiConfig.projectKey);

                processJiraData(data.issues);

                loadingSection.style.display = 'none';
                dashboardContent.style.display = 'block';

                // Update the Load Data button back to normal state
                const loadButton = document.querySelector('.load-data-btn');
                loadButton.textContent = 'Load Data';
                loadButton.title = '';
                
            } catch (error) {
                loadingSection.style.display = 'none';
                errorSection.style.display = 'block';
                errorSection.innerHTML = `<div class="error-message">Error loading data: ${error.message}</div>`;
                console.error('Error fetching Jira data:', error);
            }
        }

        // Extract text from description field (handles both plain text and ADF format)
        function extractDescriptionText(description) {
            if (!description) {
                return null;
            }

            // If it's already a string, return it
            if (typeof description === 'string') {
                return description;
            }

            // If it's ADF (Atlassian Document Format), extract text content
            if (typeof description === 'object' && description.content) {
                return extractTextFromADF(description);
            }

            // Fallback: try to stringify and clean up
            try {
                const str = JSON.stringify(description);
                // Remove JSON formatting and extract readable text
                return str.replace(/[{}"[\]]/g, '').replace(/,/g, ' ').trim();
            } catch (e) {
                console.warn('Could not extract description text:', e);
                return 'Description format not supported';
            }
        }

        // Extract text content from ADF (Atlassian Document Format)
        function extractTextFromADF(adf) {
            if (!adf || !adf.content) {
                return '';
            }

            let text = '';

            function extractFromNode(node) {
                if (node.type === 'text' && node.text) {
                    text += node.text;
                } else if (node.content && Array.isArray(node.content)) {
                    node.content.forEach(extractFromNode);
                }

                // Add line breaks for paragraph nodes
                if (node.type === 'paragraph') {
                    text += '\n';
                }
            }

            if (Array.isArray(adf.content)) {
                adf.content.forEach(extractFromNode);
            }

            return text.trim();
        }

        // Process Jira data
        function processJiraData(issues) {
            allTickets = issues.map(issue => {
                const fields = issue.fields;
                const created = new Date(fields.created);
                const resolved = fields.resolutiondate ? new Date(fields.resolutiondate) : null;
                const resolutionTime = resolved ? (resolved - created) / (1000 * 60 * 60 * 24) : null;
                
                // Process comments
                const comments = fields.comment?.comments || [];
                const processedComments = comments.map(comment => ({
                    id: comment.id,
                    author: comment.author?.displayName || 'Unknown',
                    body: extractDescriptionText(comment.body) || comment.body || '',
                    created: new Date(comment.created).toISOString().split('T')[0],
                    updated: comment.updated ? new Date(comment.updated).toISOString().split('T')[0] : null
                }));

                return {
                    key: issue.key,
                    id: issue.id,
                    summary: fields.summary,
                    description: extractDescriptionText(fields.description) || 'No description available',
                    type: fields.issuetype?.name || 'Unknown',
                    status: fields.status?.name || 'Unknown',
                    statusCategory: fields.status?.statusCategory?.name || 'Unknown',
                    priority: fields.priority?.name || 'Unprioritized',
                    assignee: fields.assignee?.displayName || 'Unassigned',
                    reporter: fields.reporter?.displayName || 'Unknown',
                    created: created.toISOString().split('T')[0],
                    resolved: resolved ? resolved.toISOString().split('T')[0] : null,
                    resolutionTime: resolutionTime,
                    components: fields.components?.map(c => c.name) || [],
                    labels: fields.labels || [],
                    comments: processedComments,
                    commentCount: processedComments.length,
                    url: `https://${apiConfig.baseUrl}/browse/${issue.key}`
                };
            });
            
            updateDashboard();
        }
        
        // Update dashboard with processed data
        function updateDashboard() {
            updateMetrics();
            updateCharts();
            updateInsights();
            updatePerformers();
            updateFilterOptions();
        }
        
        // Update metrics cards
        function updateMetrics() {
            const totalTickets = allTickets.length;
            const resolvedTickets = allTickets.filter(t => t.resolved).length;
            const resolutionRate = totalTickets > 0 ? ((resolvedTickets / totalTickets) * 100).toFixed(1) : 0;
            const avgResolutionTime = calculateAvgResolutionTime();
            const openTickets = allTickets.filter(t => !t.resolved).length;
            const inProgressTickets = allTickets.filter(t => t.status === 'In progress' || t.status === 'In Progress').length;
            const blockedTickets = allTickets.filter(t => t.status === 'Blocked').length;
            
            const metricsHtml = `
                <div class="metric-card" onclick="showAllTickets()">
                    <h3>Total Tickets</h3>
                    <div class="value">${totalTickets}</div>
                    <div class="subtitle">All time</div>
                </div>
                
                <div class="metric-card" onclick="showResolvedTickets()">
                    <h3>Resolution Rate</h3>
                    <div class="value">${resolutionRate}%</div>
                    <div class="subtitle">${resolvedTickets} resolved</div>
                </div>
                
                <div class="metric-card" onclick="showResolvedTickets()">
                    <h3>Avg Resolution Time</h3>
                    <div class="value">${avgResolutionTime.toFixed(1)}</div>
                    <div class="subtitle">days</div>
                </div>
                
                <div class="metric-card" onclick="showOpenTickets()">
                    <h3>Open Tickets</h3>
                    <div class="value">${openTickets}</div>
                    <div class="subtitle">Currently active</div>
                </div>
                
                <div class="metric-card" onclick="showTicketsByStatus('In progress')">
                    <h3>In Progress</h3>
                    <div class="value">${inProgressTickets}</div>
                    <div class="subtitle">Being worked on</div>
                </div>
                
                <div class="metric-card" onclick="showTicketsByStatus('Blocked')">
                    <h3>Blocked</h3>
                    <div class="value">${blockedTickets}</div>
                    <div class="subtitle">Need attention</div>
                </div>
            `;
            
            document.getElementById('metricsGrid').innerHTML = metricsHtml;
        }
        
        // Calculate average resolution time
        function calculateAvgResolutionTime() {
            const resolvedTickets = allTickets.filter(t => t.resolutionTime !== null);
            if (resolvedTickets.length === 0) return 0;
            
            const totalTime = resolvedTickets.reduce((sum, t) => sum + t.resolutionTime, 0);
            return totalTime / resolvedTickets.length;
        }
        
        // Update charts
        function updateCharts() {
            // Destroy existing charts
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};
            
            // Prepare data
            const issueTypes = {};
            const statuses = {};
            const priorities = {};
            const resolutionTimesByType = {};
            
            allTickets.forEach(ticket => {
                // Count by type
                issueTypes[ticket.type] = (issueTypes[ticket.type] || 0) + 1;
                
                // Count by status
                statuses[ticket.status] = (statuses[ticket.status] || 0) + 1;
                
                // Count by priority
                priorities[ticket.priority] = (priorities[ticket.priority] || 0) + 1;
                
                // Resolution times by type
                if (ticket.resolutionTime !== null) {
                    if (!resolutionTimesByType[ticket.type]) {
                        resolutionTimesByType[ticket.type] = [];
                    }
                    resolutionTimesByType[ticket.type].push(ticket.resolutionTime);
                }
            });
            
            // Calculate average resolution times by type
            const avgResolutionTimesByType = {};
            Object.entries(resolutionTimesByType).forEach(([type, times]) => {
                avgResolutionTimesByType[type] = times.reduce((a, b) => a + b, 0) / times.length;
            });
            
            // Create charts
            createIssueTypeChart(issueTypes);
            createStatusChart(statuses);
            createPriorityChart(priorities);
            createResolutionTimeChart(avgResolutionTimesByType);
        }
        
        // Create individual charts
        function createIssueTypeChart(data) {
            const ctx = document.getElementById('issueTypeChart').getContext('2d');
            charts.issueType = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(data),
                    datasets: [{
                        data: Object.values(data),
                        backgroundColor: [
                            '#667eea',
                            '#764ba2',
                            '#f093fb',
                            '#4facfe',
                            '#fa709a',
                            '#feca57',
                            '#48c6ef',
                            '#f093fb'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    onClick: (event, elements) => {
                        console.log('Issue Type Chart clicked:', elements);
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const type = Object.keys(data)[index];
                            console.log('Showing tickets by type:', type);
                            showTicketsByType(type);
                        }
                    },
                    onHover: (event, elements) => {
                        event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                color: '#a8a8b3'
                            },
                            onClick: (event, legendItem, legend) => {
                                const index = legendItem.index;
                                const type = Object.keys(data)[index];
                                console.log('Legend clicked for type:', type);
                                showTicketsByType(type);
                            }
                        },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function createStatusChart(data) {
            const ctx = document.getElementById('statusChart').getContext('2d');
            charts.status = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(data),
                    datasets: [{
                        label: 'Tickets',
                        data: Object.values(data),
                        backgroundColor: '#667eea',
                        borderRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    onClick: (event, elements) => {
                        console.log('Status Chart clicked:', elements);
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const status = Object.keys(data)[index];
                            console.log('Showing tickets by status:', status);
                            showTicketsByStatus(status);
                        }
                    },
                    onHover: (event, elements) => {
                        event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed.y || 0;
                                    return `${label}: ${value} tickets`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#2a2a4e'
                            },
                            ticks: {
                                color: '#a8a8b3'
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: '#a8a8b3'
                            }
                        }
                    }
                }
            });
        }
        
        function createPriorityChart(data) {
            const ctx = document.getElementById('priorityChart').getContext('2d');
            charts.priority = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(data),
                    datasets: [{
                        data: Object.values(data),
                        backgroundColor: [
                            '#888',
                            '#f093fb',
                            '#fa709a',
                            '#feca57',
                            '#48c6ef'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    onClick: (event, elements) => {
                        console.log('Priority Chart clicked:', elements);
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const priority = Object.keys(data)[index];
                            console.log('Showing tickets by priority:', priority);
                            showTicketsByPriority(priority);
                        }
                    },
                    onHover: (event, elements) => {
                        event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                color: '#a8a8b3'
                            },
                            onClick: (event, legendItem, legend) => {
                                const index = legendItem.index;
                                const priority = Object.keys(data)[index];
                                console.log('Legend clicked for priority:', priority);
                                showTicketsByPriority(priority);
                            }
                        },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function createResolutionTimeChart(data) {
            const ctx = document.getElementById('resolutionTimeChart').getContext('2d');
            
            // Sort by resolution time for better visualization
            const sorted = Object.entries(data).sort((a, b) => a[1] - b[1]);
            
            charts.resolutionTime = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sorted.map(([type, _]) => type),
                    datasets: [{
                        label: 'Days',
                        data: sorted.map(([_, time]) => time),
                        backgroundColor: [
                            '#667eea',
                            '#764ba2',
                            '#f093fb',
                            '#4facfe',
                            '#fa709a',
                            '#feca57'
                        ],
                        borderRadius: 5
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    onClick: (event, elements) => {
                        console.log('Resolution Time Chart clicked:', elements);
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const type = sorted[index][0];
                            console.log('Showing resolved tickets by type:', type);
                            showResolvedTicketsByType(type);
                        }
                    },
                    onHover: (event, elements) => {
                        event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed.x || 0;
                                    return `${label}: ${value.toFixed(1)} days`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: {
                                color: '#2a2a4e'
                            },
                            ticks: {
                                color: '#a8a8b3'
                            }
                        },
                        y: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: '#a8a8b3'
                            }
                        }
                    }
                }
            });
        }
        
        // Update insights section
        function updateInsights() {
            const insights = generateInsights();
            let insightsHtml = '<h2>Key Insights & Recommendations</h2>';
            
            insights.forEach(insight => {
                insightsHtml += `
                    <div class="insight-item">
                        <h4>${insight.title}</h4>
                        <p>${insight.description}</p>
                    </div>
                `;
            });
            
            document.getElementById('insightsSection').innerHTML = insightsHtml;
        }
        
        // Generate insights based on data
        function generateInsights() {
            const insights = [];
            
            // Resolution time insight
            const resolutionTimes = {};
            allTickets.forEach(ticket => {
                if (ticket.resolutionTime !== null) {
                    if (!resolutionTimes[ticket.type]) {
                        resolutionTimes[ticket.type] = [];
                    }
                    resolutionTimes[ticket.type].push(ticket.resolutionTime);
                }
            });
            
            let maxAvgTime = 0;
            let maxType = '';
            let minAvgTime = Infinity;
            let minType = '';
            
            Object.entries(resolutionTimes).forEach(([type, times]) => {
                const avg = times.reduce((a, b) => a + b, 0) / times.length;
                if (avg > maxAvgTime) {
                    maxAvgTime = avg;
                    maxType = type;
                }
                if (avg < minAvgTime) {
                    minAvgTime = avg;
                    minType = type;
                }
            });
            
            if (maxType && minType) {
                insights.push({
                    title: '⚡ Resolution Times Vary Significantly',
                    description: `${maxType} tickets take the longest (avg ${maxAvgTime.toFixed(1)} days), while ${minType} are resolved fastest (${minAvgTime.toFixed(1)} days). Consider standardizing processes for complex ticket types.`
                });
            }
            
            // Volume insight
            const typeDistribution = {};
            allTickets.forEach(ticket => {
                typeDistribution[ticket.type] = (typeDistribution[ticket.type] || 0) + 1;
            });
            
            const sortedTypes = Object.entries(typeDistribution).sort((a, b) => b[1] - a[1]);
            if (sortedTypes.length > 0) {
                const topType = sortedTypes[0];
                const percentage = ((topType[1] / allTickets.length) * 100).toFixed(0);
                insights.push({
                    title: '📊 High Volume Category',
                    description: `${percentage}% of tickets are ${topType[0]}. This suggests customers may need better self-service options or clearer categorization for this type of request.`
                });
            }
            
            // Backlog insight
            const oldTickets = allTickets.filter(t => {
                if (!t.resolved) {
                    const daysOpen = (new Date() - new Date(t.created)) / (1000 * 60 * 60 * 24);
                    return daysOpen > 30;
                }
                return false;
            });
            
            if (oldTickets.length > 0) {
                const oldestDays = Math.max(...oldTickets.map(t => 
                    (new Date() - new Date(t.created)) / (1000 * 60 * 60 * 24)
                ));
                insights.push({
                    title: '⚠️ Aging Tickets Need Attention',
                    description: `${oldTickets.length} tickets have been open for over 30 days, with the oldest being ${oldestDays.toFixed(0)} days old. These aged tickets need immediate attention or re-evaluation.`
                });
            }
            
            // Priority insight
            const unprioritized = allTickets.filter(t => t.priority === 'Unprioritized').length;
            if (unprioritized > 0) {
                const percentage = ((unprioritized / allTickets.length) * 100).toFixed(0);
                insights.push({
                    title: '🎯 Priority Management Opportunity',
                    description: `${percentage}% of tickets are unprioritized. Implementing a better triage process could help focus efforts on critical customer needs.`
                });
            }
            
            return insights;
        }
        
        // Update performers section
        function updatePerformers() {
            const assigneeCounts = {};
            allTickets.forEach(ticket => {
                if (ticket.assignee !== 'Unassigned') {
                    assigneeCounts[ticket.assignee] = (assigneeCounts[ticket.assignee] || 0) + 1;
                }
            });
            
            const sortedAssignees = Object.entries(assigneeCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            let performersHtml = `
                <div class="performer-card">
                    <h4>Top Assignees by Volume</h4>
            `;
            
            sortedAssignees.forEach(([assignee, count]) => {
                const percentage = ((count / allTickets.length) * 100).toFixed(1);
                performersHtml += `
                    <div class="performer-item" onclick="showTicketsByAssignee('${assignee}')" style="cursor: pointer;">
                        <span>${assignee}</span>
                        <span>${count} tickets (${percentage}%)</span>
                    </div>
                `;
            });
            
            performersHtml += '</div>';
            
            // Quick resolution categories
            const resolutionTimesByType = {};
            allTickets.forEach(ticket => {
                if (ticket.resolutionTime !== null) {
                    if (!resolutionTimesByType[ticket.type]) {
                        resolutionTimesByType[ticket.type] = [];
                    }
                    resolutionTimesByType[ticket.type].push(ticket.resolutionTime);
                }
            });
            
            const avgTimesByType = Object.entries(resolutionTimesByType)
                .map(([type, times]) => ({
                    type,
                    avg: times.reduce((a, b) => a + b, 0) / times.length
                }))
                .sort((a, b) => a.avg - b.avg)
                .slice(0, 3);
            
            performersHtml += `
                <div class="performer-card">
                    <h4>Quick Resolution Categories</h4>
            `;
            
            const maxTime = Math.max(...avgTimesByType.map(t => t.avg));
            avgTimesByType.forEach(({type, avg}) => {
                const percentage = (avg / maxTime) * 100;
                performersHtml += `
                    <div class="performer-item">
                        <span>${type}</span>
                        <span>${avg.toFixed(1)} days avg</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${percentage}%"></div>
                    </div>
                `;
            });
            
            performersHtml += '</div>';
            
            document.getElementById('performersSection').innerHTML = performersHtml;
        }
        
        // Update filter options
        function updateFilterOptions() {
            const statuses = [...new Set(allTickets.map(t => t.status))].sort();
            const types = [...new Set(allTickets.map(t => t.type))].sort();
            const assignees = [...new Set(allTickets.map(t => t.assignee))].sort();
            
            const statusFilter = document.getElementById('statusFilter');
            statusFilter.innerHTML = '<option value="">All Statuses</option>';
            statuses.forEach(status => {
                statusFilter.innerHTML += `<option value="${status}">${status}</option>`;
            });
            
            const typeFilter = document.getElementById('typeFilter');
            typeFilter.innerHTML = '<option value="">All Types</option>';
            types.forEach(type => {
                typeFilter.innerHTML += `<option value="${type}">${type}</option>`;
            });
            
            const assigneeFilter = document.getElementById('assigneeFilter');
            assigneeFilter.innerHTML = '<option value="">All Assignees</option>';
            assignees.forEach(assignee => {
                assigneeFilter.innerHTML += `<option value="${assignee}">${assignee}</option>`;
            });
        }
        
        // Modal functions
        function showModal(title, content) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalContent').innerHTML = content;
            document.getElementById('dataModal').style.display = 'block';
            
            // Reset filters
            document.getElementById('searchBox').value = '';
            document.getElementById('statusFilter').value = '';
            document.getElementById('typeFilter').value = '';
            document.getElementById('assigneeFilter').value = '';
        }
        
        function closeModal() {
            document.getElementById('dataModal').style.display = 'none';
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('dataModal');
            if (event.target == modal) {
                closeModal();
            }
        }
        
        // Filter table function
        function filterTable() {
            const searchValue = document.getElementById('searchBox').value.toLowerCase();
            const statusValue = document.getElementById('statusFilter').value;
            const typeValue = document.getElementById('typeFilter').value;
            const assigneeValue = document.getElementById('assigneeFilter').value;
            
            const rows = document.querySelectorAll('#ticketTable tbody tr');
            
            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const status = row.querySelector('.status-badge').textContent;
                const type = row.cells[2].textContent;
                const assignee = row.cells[5].textContent;
                
                const matchesSearch = text.includes(searchValue);
                const matchesStatus = !statusValue || status === statusValue;
                const matchesType = !typeValue || type === typeValue;
                const matchesAssignee = !assigneeValue || assignee === assigneeValue;
                
                row.style.display = matchesSearch && matchesStatus && matchesType && matchesAssignee ? '' : 'none';
            });
        }
        
        // Generate table HTML with expandable descriptions
        function generateTable(tickets) {
            let html = `
                <table class="data-table" id="ticketTable">
                    <thead>
                        <tr>
                            <th>Ticket</th>
                            <th>Summary</th>
                            <th>Type</th>
                            <th>Status</th>
                            <th>Priority</th>
                            <th>Assignee</th>
                            <th>Reporter</th>
                            <th>Comments</th>
                            <th>Created</th>
                            <th>Resolved</th>
                            <th>Time (days)</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            tickets.forEach((ticket, index) => {
                const statusClass = ticket.status.toLowerCase().replace(' ', '-');
                const resolutionTime = ticket.resolutionTime ? `${ticket.resolutionTime.toFixed(1)}` : '-';
                
                html += `
                    <tr>
                        <td><a href="${ticket.url}" target="_blank">${ticket.key}</a></td>
                        <td>${ticket.summary}</td>
                        <td>${ticket.type}</td>
                        <td><span class="status-badge status-${statusClass}">${ticket.status}</span></td>
                        <td>${ticket.priority}</td>
                        <td>${ticket.assignee}</td>
                        <td>${ticket.reporter}</td>
                        <td>${ticket.commentCount || 0}</td>
                        <td>${ticket.created}</td>
                        <td>${ticket.resolved || '-'}</td>
                        <td>${resolutionTime}</td>
                        <td><button class="expand-btn" onclick="toggleDescription('desc-${index}')">Details</button></td>
                    </tr>
                    <tr>
                        <td colspan="12">
                            <div id="desc-${index}" class="ticket-description">
                                <strong>Description:</strong><br>
                                ${ticket.description && typeof ticket.description === 'string' ? ticket.description.replace(/\n/g, '<br>') : 'No description available'}
                                ${ticket.components && Array.isArray(ticket.components) && ticket.components.length > 0 ? `<br><br><strong>Components:</strong> ${ticket.components.join(', ')}` : ''}
                                ${ticket.labels && Array.isArray(ticket.labels) && ticket.labels.length > 0 ? `<br><strong>Labels:</strong> ${ticket.labels.join(', ')}` : ''}
                                ${ticket.comments && Array.isArray(ticket.comments) && ticket.comments.length > 0 ?
                                    `<br><br><strong>Comments (${ticket.comments.length}):</strong><br>` +
                                    ticket.comments.map(comment =>
                                        `<div style="margin: 8px 0; padding: 8px; background: #1a1a2e; border-radius: 4px;">
                                            <strong>${comment.author}</strong> <em>(${comment.created})</em><br>
                                            ${comment.body.replace(/\n/g, '<br>')}
                                        </div>`
                                    ).join('') :
                                    '<br><br><strong>Comments:</strong> No comments'
                                }
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Toggle description visibility
        function toggleDescription(id) {
            const desc = document.getElementById(id);
            desc.classList.toggle('show');
        }
        
        // Show functions for different views
        function showAllTickets() {
            showModal('All Tickets', generateTable(allTickets));
        }
        
        function showOpenTickets() {
            const openTickets = allTickets.filter(t => !t.resolved);
            showModal('Open Tickets', generateTable(openTickets));
        }
        
        function showResolvedTickets() {
            const resolvedTickets = allTickets.filter(t => t.resolved);
            showModal('Resolved Tickets', generateTable(resolvedTickets));
        }
        
        function showTicketsByStatus(status) {
            const filtered = allTickets.filter(t => t.status === status);
            showModal(`Tickets - ${status}`, generateTable(filtered));
        }
        
        function showTicketsByType(type) {
            const filtered = allTickets.filter(t => t.type === type);
            showModal(`${type} Tickets`, generateTable(filtered));
        }
        
        function showTicketsByPriority(priority) {
            const filtered = allTickets.filter(t => t.priority === priority);
            showModal(`${priority} Priority Tickets`, generateTable(filtered));
        }
        
        function showTicketsByAssignee(assignee) {
            const filtered = allTickets.filter(t => t.assignee === assignee);
            showModal(`Tickets Assigned to ${assignee}`, generateTable(filtered));
        }
        
        function showResolvedTicketsByType(type) {
            const filtered = allTickets.filter(t => t.type === type && t.resolved);
            showModal(`Resolved ${type} Tickets`, generateTable(filtered));
        }
        
        // AI Analysis Functions
        function analyzeWithAI() {
            const apiKey = document.getElementById('openaiApiKey').value;
            const model = document.getElementById('openaiModel').value;
            
            if (!apiKey) {
                alert('Please enter your OpenAI API key');
                return;
            }
            
            if (allTickets.length === 0) {
                alert('Please load Jira data first');
                return;
            }
            
            openaiConfig.apiKey = apiKey;
            openaiConfig.model = model;
            
            // Show analysis modal
            showModal('AI Analysis', '<div class="loading-spinner"></div><p>Analyzing issues with AI...</p>');
            
            performAIAnalysis();
        }
        
        async function performAIAnalysis() {
            try {
                // Prepare data for analysis
                const analysisData = {
                    totalIssues: allTickets.length,
                    byStatus: {},
                    byType: {},
                    byPriority: {},
                    avgResolutionTime: {},
                    topIssues: allTickets.slice(0, 20).map(t => ({
                        key: t.key,
                        summary: t.summary,
                        description: t.description,
                        status: t.status,
                        type: t.type,
                        priority: t.priority,
                        created: t.created,
                        assignee: t.assignee,
                        reporter: t.reporter,
                        components: t.components,
                        labels: t.labels,
                        comments: t.comments,
                        commentCount: t.commentCount,
                        resolutionTime: t.resolutionTime
                    }))
                };
                
                // Calculate metrics
                allTickets.forEach(ticket => {
                    analysisData.byStatus[ticket.status] = (analysisData.byStatus[ticket.status] || 0) + 1;
                    analysisData.byType[ticket.type] = (analysisData.byType[ticket.type] || 0) + 1;
                    analysisData.byPriority[ticket.priority] = (analysisData.byPriority[ticket.priority] || 0) + 1;
                });
                
                // Make API call to OpenAI through our proxy
                const requestBody = {
                    model: openaiConfig.model || 'o3',
                    messages: [{
                        role: 'system',
                        content: `You are a Jira project analyst. Analyze the provided issue data and provide insights on team performance, bottlenecks, and recommendations for improvement.

                        IMPORTANT: When discussing specific tickets, ALWAYS include:
                        - **Reporter**: Who reported the issue
                        - **Assignee**: Who is assigned to work on it
                        - **Customer**: Check components, labels, or reporter field for customer information
                        - **Comment History**: Include relevant comments and their authors when available

                        Format your analysis with clear sections and use markdown for better readability.`
                        }, {
                            role: 'user',
                            content: `Please analyze this Jira project data and provide insights:\n\n${JSON.stringify(analysisData, null, 2)}`
                        }]
                };

                // Only include apiKey if we have one (not using stored credentials)
                if (openaiConfig.apiKey) {
                    requestBody.apiKey = openaiConfig.apiKey;
                }

                const response = await fetch('/api/openai-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to get AI analysis');
                }
                
                const result = await response.json();
                
                // Display analysis
                const analysisHtml = `
                    <div class="ai-analysis">
                        <h3>AI Analysis Results</h3>
                        <div style="white-space: pre-wrap; line-height: 1.6; color: #e0e0e0;">
                            ${result.content}
                        </div>
                    </div>
                `;
                
                document.getElementById('modalContent').innerHTML = analysisHtml;
                
            } catch (error) {
                console.error('AI Analysis error:', error);
                document.getElementById('modalContent').innerHTML = 
                    `<div class="error-message">Error performing AI analysis: ${error.message}</div>`;
            }
        }
        
        // Enable/disable AI analysis button based on data availability
        function updateAnalyzeButton() {
            const button = document.getElementById('analyzeButton');
            if (button) {
                button.disabled = allTickets.length === 0;
            }
        }
    </script>
</body>
</html>